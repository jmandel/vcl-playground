<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VCL: ValueSet Compose Language &mdash; Specification</title>
<style>
:root {
  --bg: #fafafa; --fg: #1a1a2e; --muted: #64748b; --border: #e2e8f0;
  --accent: #2563eb; --accent-light: #dbeafe; --accent-dark: #1e40af;
  --code-bg: #f1f5f9; --note-bg: #fef3c7; --note-border: #f59e0b;
  --font: system-ui, -apple-system, 'Segoe UI', sans-serif;
  --mono: 'SF Mono', 'Cascadia Code', 'Fira Code', Consolas, monospace;
}
*, *::before, *::after { box-sizing: border-box; }
body { font-family: var(--font); color: var(--fg); background: var(--bg); margin: 0; line-height: 1.7; font-size: 16px; }
h1, h2, h3, h4 { line-height: 1.3; margin-top: 2.5em; margin-bottom: 0.5em; }
h1 { font-size: 2rem; margin-top: 0; }
h2 { font-size: 1.4rem; border-bottom: 2px solid var(--accent); padding-bottom: 0.25em; }
h3 { font-size: 1.15rem; color: var(--accent-dark); }
a { color: var(--accent); }
.container { max-width: 1100px; margin: 0 auto; padding: 2rem 1.5rem; }
code { font-family: var(--mono); font-size: 0.88em; background: var(--code-bg); padding: 0.15em 0.4em; border-radius: 3px; }
pre { background: var(--code-bg); padding: 1em 1.25em; border-radius: 6px; overflow-x: auto; font-family: var(--mono); font-size: 0.85em; line-height: 1.55; }
pre code { background: none; padding: 0; }
table { width: 100%; border-collapse: collapse; margin: 1em 0; font-size: 0.92em; }
th, td { padding: 0.5em 0.75em; text-align: left; border-bottom: 1px solid var(--border); }
th { background: var(--code-bg); font-weight: 600; }
td code { white-space: nowrap; }
.note { background: var(--note-bg); border-left: 4px solid var(--note-border); padding: 0.75em 1em; margin: 1em 0;
  border-radius: 0 6px 6px 0; font-size: 0.93em; }
.try-link { font-size: 0.85em; margin-left: 0.5em; }
.try-link::before { content: '\25B6\00A0'; font-size: 0.75em; }
nav { background: white; border-bottom: 1px solid var(--border); padding: 0.5em 1.5em; position: sticky; top: 0; z-index: 100;
  display: flex; gap: 1.5em; flex-wrap: wrap; font-size: 0.82em; }
nav a { text-decoration: none; color: var(--muted); padding: 0.25em 0; white-space: nowrap; }
nav a:hover { color: var(--accent); }
#branch-picker-slot { margin-left: auto; display: inline-flex; align-items: center; gap: 0.4em; color: var(--muted); }
#branch-picker-slot label { font-size: 0.9em; }
#branch-picker-slot select { font-size: 0.9em; border: 1px solid var(--border); border-radius: 4px; background: white; color: var(--fg); padding: 0.2em 0.35em; max-width: 18rem; }

/* Definition lists */
dl { margin: 1em 0; }
dt { font-weight: 600; margin-top: 0.75em; }
dd { margin-left: 1.5em; margin-bottom: 0.5em; }

/* Grammar */
.grammar { background: var(--code-bg); border-radius: 6px; padding: 1em 1.25em; font-family: var(--mono);
  font-size: 0.82em; line-height: 1.65; overflow-x: auto; white-space: pre; }
.grammar .nt { color: #2563eb; } /* non-terminal */
.grammar .t { color: #059669; font-weight: 600; } /* terminal */
.grammar .c { color: #94a3b8; font-style: italic; } /* comment */

/* Side-by-side */
.side-by-side { display: grid; grid-template-columns: 1fr 1fr; gap: 1em; margin: 1em 0; }
.side-by-side > div { min-width: 0; }
.side-by-side h4 { margin: 0 0 0.25em; font-size: 0.8em; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; }
@media (max-width: 700px) { .side-by-side { grid-template-columns: 1fr; } }

.subtitle { color: var(--muted); font-size: 0.95em; margin-top: -0.5em; margin-bottom: 2em; }

/* Heading anchor links */
h2, h3 { position: relative; }
h2 .anchor-link, h3 .anchor-link {
  opacity: 0; margin-left: 0.3em; color: var(--muted); text-decoration: none;
  font-size: 0.75em; font-weight: 400; vertical-align: middle; transition: opacity 0.15s;
}
h2:hover .anchor-link, h3:hover .anchor-link { opacity: 1; }
h2 .anchor-link:hover, h3 .anchor-link:hover { color: var(--accent); }
.anchor-link.copied { opacity: 1; color: var(--accent); }
</style>
</head>
<body>

<nav>
  <a href="#overview">Overview</a>
  <a href="#basics">Basics</a>
  <a href="#structure">Structure</a>
  <a href="#expressions">Expressions</a>
  <a href="#operators">Operators</a>
  <a href="#system-scoping">System Scoping</a>
  <a href="#implicit-uris">Implicit URIs</a>
  <a href="#compose-mapping">Compose Mapping</a>
  <a href="#grammar">Grammar</a>
  <a href="tutorial.html" style="color: var(--accent);">Interactive Tutorial &rarr;</a>
  <span id="branch-picker-slot"></span>
</nav>

<div class="container">

<!-- ================================================================ -->
<section id="overview">
<h1>VCL: ValueSet Compose Language</h1>
<p class="subtitle">A compact syntax for defining FHIR ValueSets</p>

<p>
  ValueSet Compose Language (VCL) is a domain-specific language for defining
  <a href="https://hl7.org/fhir/valueset-definitions.html#ValueSet.compose">ValueSet.compose</a>
  content in a compact, URL-safe textual form. A VCL expression specifies which codes to include in
  (and optionally exclude from) a ValueSet by declaring filters over code system properties,
  navigating relationships between concepts, and composing results with set operations.
</p>
<p>
  VCL works with any FHIR CodeSystem. It is particularly useful for:
</p>
<ul>
  <li><strong>Dynamic ValueSet definitions</strong> &mdash; expressing intensional value sets
    (defined by rules rather than enumerated codes) in a single compact string</li>
  <li><strong>Implicit ValueSet URIs</strong> &mdash; encoding a ValueSet definition directly
    in a URL, enabling ad-hoc <code>$expand</code> requests without pre-registering a ValueSet resource</li>
  <li><strong>Multi-system ValueSets</strong> &mdash; combining codes from multiple code systems
    in a single expression</li>
</ul>
<p>
  Every VCL expression has a direct correspondence to a <code>ValueSet.compose</code> JSON/XML structure.
  VCL does not add capabilities beyond what <code>ValueSet.compose</code> supports; it provides a
  more readable and writable syntax for the same underlying model.
</p>

<div class="note">
  VCL was designed by Michael Lawley (CSIRO) and is formally specified in the
  <a href="https://build.fhir.org/ig/FHIR/ig-guidance/vcl.html">FHIR IG Guidance</a>.
  This page provides an expanded specification with definitions, examples, and links to an
  <a href="tutorial.html">interactive tutorial</a> with a live RxNorm dataset.
</div>
</section>

<!-- ================================================================ -->
<section id="basics">
<h2>Basics</h2>

<h3>Grammar</h3>
<p>
  VCL has a formal grammar defined in <a href="https://www.antlr.org/">ANTLR</a>
  (see <a href="#grammar">Formal Grammar</a>). Conforming implementations <strong>SHALL</strong>
  accept all syntactically valid expressions as defined by this grammar.
</p>

<h3>Whitespace</h3>
<p>
  Spaces, tabs, newlines, and carriage returns are insignificant and ignored everywhere except
  within quoted values. Implementations may canonicalize expressions to compact single-line form
  when embedding in URL parameters and JSON string values.
</p>

<h3>Codes and Literals</h3>
<p>
  A <strong>code</strong> in VCL is either:
</p>
<ul>
  <li>An <strong>unquoted simple code</strong> (<code>SCODE</code>): starts with an alphanumeric character,
    followed by zero or more alphanumeric characters, hyphens, or underscores.
    Examples: <code>161</code>, <code>SCD</code>, <code>LP15653-6</code></li>
  <li>An <strong>explicit quoted code</strong>: enclosed in single quotes (<code>'</code>) with backslash
    (<code>\</code>) escapes. Example: <code>'J45.0'</code></li>
</ul>
<p>
  Codes containing characters other than <code>[a-zA-Z0-9_-]</code> <strong>MUST</strong> be single-quoted.
</p>
<p>
  Non-code scalar literals use explicit syntax:
  strings <code>"text"</code>, numbers <code>num:42</code>, booleans <code>bool:true</code>/<code>bool:false</code>,
  and dates <code>date:YYYY-MM-DD</code>.
</p>
<pre><code data-vcl-expr-key="typed-code-explicit"></code></pre>
<pre><code data-vcl-expr-key="typed-string-explicit"></code></pre>
<pre><code data-vcl-expr-key="typed-number-explicit"></code></pre>
<pre><code data-vcl-expr-key="typed-boolean-explicit"></code></pre>
<pre><code data-vcl-expr-key="typed-date-explicit"></code></pre>

<h3>URIs</h3>
<p>
  URIs in VCL must begin with a scheme of one or more ASCII letters followed by a colon.
  Parentheses within URIs <strong>MUST</strong> be percent-encoded (<code>%28</code> / <code>%29</code>)
  because VCL uses parentheses as delimiters for system scoping.
</p>

<h3>Comments</h3>
<p>There is no syntax for comments in VCL.</p>
</section>

<!-- ================================================================ -->
<section id="structure">
<h2>Structure</h2>
<p>
  VCL maps directly to
  <a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose"><code>ValueSet.compose</code></a>,
  which defines a ValueSet intensionally (by rules) rather than extensionally (by enumeration).
  A <code>compose</code> element contains:
</p>
<ul>
  <li><a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.include"><code>include</code></a>
    &mdash; one or more inclusion rules (their union defines the included codes)</li>
  <li><a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.exclude"><code>exclude</code></a>
    &mdash; optional exclusion rules (codes matching these are removed from the result)</li>
</ul>
<p>
  Each <code>include</code>/<code>exclude</code> targets a
  <a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.include.system"><code>system</code></a>
  and specifies codes via
  <a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.include.concept"><code>concept</code></a> (enumerated),
  <a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.include.filter"><code>filter</code></a> (property-based rules), or
  <a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.include.valueSet"><code>valueSet</code></a> (reference to another ValueSet).
  VCL provides compact syntax for all of these.
</p>
<p>
  A VCL expression specifies:
</p>
<ol>
  <li>An <strong>inclusion rule</strong>: which codes to include</li>
  <li>An optional <strong>exclusion rule</strong>: which codes to remove from the included set</li>
</ol>
<p>
  Both inclusion and exclusion rules are built from <strong>sub-expressions</strong> combined with
  set operations:
</p>
<dl>
  <dt>Conjunction (AND) &mdash; <code>,</code></dt>
  <dd>
    <p>The <strong>intersection</strong> of two or more sub-expressions. A code is included only if it
    satisfies every sub-expression.</p>
    <pre><code data-vcl-expr-key="and-ingredient-df"></code></pre>
    <p>Concepts containing acetaminophen <em>and</em> in oral tablet form.
    Maps to multiple <code>filter</code> entries within a single <code>include</code> element.
    <a class="try-link" href="tutorial.html#example=and-ingredient-df">Try it</a></p>
  </dd>

  <dt>Disjunction (OR) &mdash; <code>;</code></dt>
  <dd>
    <p>The <strong>union</strong> of two or more sub-expressions. A code is included if it
    satisfies any sub-expression.</p>
    <pre><code data-vcl-expr-key="or-ingredients"></code></pre>
    <p>Concepts containing acetaminophen <em>or</em> ibuprofen.
    Maps to separate <code>include</code> elements.
    <a class="try-link" href="tutorial.html#example=or-ingredients">Try it</a></p>
  </dd>

  <dt>Exclusion (MINUS) &mdash; <code>-</code></dt>
  <dd>
    <p><strong>Set subtraction</strong>. Codes matching the right side are removed from the left side result.</p>
    <pre><code data-vcl-expr-key="exclusion"></code></pre>
    <p>Concepts containing acetaminophen, excluding those also containing hydrocodone.
    The left side maps to <code>compose.include</code>; the right side to <code>compose.exclude</code>.
    <a class="try-link" href="tutorial.html#example=exclusion">Try it</a></p>
  </dd>
</dl>

<h3>Grouping and Precedence</h3>
<p>
  There are <strong>no operator precedence rules</strong> between <code>,</code> and <code>;</code>.
  Parentheses <code>(</code>...<code>)</code> <strong>MUST</strong> be used to group sub-expressions
  when mixing conjunction and disjunction:
</p>
<pre><code data-vcl-expr-key="mixed-grouping-tablets"></code></pre>
<p>
  Acetaminophen oral tablets OR ibuprofen oral tablets. Without parentheses, the grouping is
  ambiguous and implementations <strong>SHOULD</strong> reject it.
</p>
<p>
  Each sub-expression evaluates to a set of codes and is one of:
</p>
<ul>
  <li>A <strong>code literal</strong> &mdash; a single code</li>
  <li>A <strong>wildcard</strong> (<code>*</code>) &mdash; all codes in the code system</li>
  <li>A <strong>filter</strong> &mdash; a property/operator/value triple that selects codes based on properties</li>
  <li>A <strong>ValueSet include</strong> &mdash; reference to another ValueSet</li>
  <li>A <strong>grouped expression</strong> &mdash; a parenthesized sub-expression</li>
</ul>
</section>

<!-- ================================================================ -->
<section id="expressions">
<h2>Expressions</h2>

<h3 id="expr-code">Code Literals</h3>
<p>
  The simplest VCL expression is a code literal. It evaluates to a set containing exactly that one concept
  (if it exists in the code system).
</p>
<pre><code data-vcl-expr-key="code-161"></code></pre>
<p>
  Selects the single concept with code <code>161</code>.
  <a class="try-link" href="tutorial.html#example=code-161">Try it</a>
</p>

<h3 id="expr-star">Wildcard</h3>
<p>
  The wildcard <code>*</code> matches all codes in the (scoped) code system.
</p>
<pre><code data-vcl-expr-key="star"></code></pre>

<h3 id="expr-filter">Filters</h3>
<p>
  A filter selects codes based on the value of a named property. The general form is:
</p>
<pre><code>{property} {operator} {value}</code></pre>
<p>
  Where <code>{property}</code> is the property name (a code), <code>{operator}</code> is one of the
  <a href="#operators">VCL operators</a>, and <code>{value}</code> depends on the operator.
</p>
<p>
  For example, with the <code>=</code> operator:
</p>
<pre><code data-vcl-expr-key="filter-ingredient"></code></pre>
<p>
  Selects all concepts whose <code>has_ingredient</code> property has the value <code>161</code>.
  In RxNorm, this returns drug components (SCDCs) containing acetaminophen.
  <a class="try-link" href="tutorial.html#example=filter-ingredient">Try it</a>
</p>
<p>
  Filters work with both <strong>concept-valued properties</strong> (edges to other concepts in
  the code system) and <strong>literal-valued properties</strong> (string/boolean values):
</p>
<pre><code data-vcl-expr-key="filter-tty"></code></pre>
<p>
  Selects all concepts whose <code>TTY</code> (term type) literal property equals code <code>SCD</code>.
  A string comparison uses double quotes (for example <code>TTY="SCD"</code>).
  <a class="try-link" href="tutorial.html#example=filter-tty">Try it</a>
</p>
<p>
  Filters map directly to <code>ValueSet.compose.include.filter</code> elements. Each filter
  produces a single <code>filter</code> entry with <code>property</code>, <code>op</code>, and <code>value</code>.
</p>

<h3 id="expr-of">The "of" Operator (Property Navigation)</h3>
<p>
  The <code>.</code> (dot) operator reverses the direction of a filter. Instead of asking
  "which codes have this property value?", it asks "starting from this code, what does this
  property point to?"
</p>
<pre><code>{value} . {property}</code></pre>
<p>
  This corresponds to the FHIR R6 <code>of</code> filter operator, which reverses the
  <code>property</code>/<code>value</code> roles: the left side is the value (starting point)
  and the right side is the property to follow.
</p>
<pre><code data-vcl-expr-key="of-tradename"></code></pre>
<p>
  Start at concept <code>104906</code> (acetaminophen 24 MG/ML Oral Solution), follow the
  <code>has_tradename</code> relationship outward. Returns all branded versions of that drug.
  <a class="try-link" href="tutorial.html#example=of-tradename">Try it</a>
</p>
<p>
  The value side of <code>.</code> can be any expression that produces a set of codes.
  Parentheses group a sub-expression for multi-hop traversal:
</p>
<pre><code data-vcl-expr-key="of-chained"></code></pre>
<p>
  Start at an SCD &rarr; follow <code>has_tradename</code> (yields SBDs) &rarr;
  follow <code>has_ingredient</code> (yields brand names). This chains two navigation steps.
  <a class="try-link" href="tutorial.html#example=of-chained">Try it</a>
</p>
<p>
  The left side of <code>.</code> may also be a grouped expression, wildcard, URI, or filter expression:
</p>
<pre><code data-vcl-expr-key="of-from-filtered-set"></code></pre>
<p>
  Find concepts matching both filters, then follow <code>has_tradename</code> on each.
</p>

<h3 id="expr-in">The "in" Operator with Set Expressions</h3>
<p>
  The <code>^</code> (<code>in</code>) operator tests whether a property's value is a member
  of a specified set. The set can be:
</p>

<h4>A code set expression</h4>
<p>
  A semicolon-separated list of codes in parentheses.
  A parenthesized code set may contain one or more codes.
</p>
<pre><code data-vcl-expr-key="in-code-list-spaced"></code></pre>
<p>
  Concepts whose <code>has_ingredient</code> value is <code>161</code>, <code>5640</code>, or
  <code>1191</code> (acetaminophen, ibuprofen, or aspirin).
  <a class="try-link" href="tutorial.html#example=in-code-list">Try it</a>
</p>

<h4>A nested expression</h4>
<p>
  A parenthesized expression using standard VCL operators. This enables <strong>graph traversal through
  intermediate nodes</strong>: the property must point to a concept that itself matches
  the nested expression.
</p>
<pre><code data-vcl-expr-key="in-filter-list-spaced"></code></pre>
<p>
  Concepts whose <code>consists_of</code> property points to a concept that has
  <code>has_ingredient = 161</code>. In RxNorm: SCDs that consist of a component
  containing acetaminophen.
  <a class="try-link" href="tutorial.html#example=in-filter-list">Try it</a>
</p>
<p>
  Nested expressions can nest further:
</p>
<pre><code data-vcl-expr-key="in-nested-tradename-spaced"></code></pre>
<p>
  SCDs consisting of a component whose ingredient has a specific trade name.
</p>
<p>
  Rewrite equivalence: <code>a.b OP x</code> is syntactic sugar for <code>a^(b OP x)</code>.
</p>
<p>
  To OR across different property paths, use explicit disjunction:
  <code>consists_of.has_ingredient=1191;has_ingredient=1191</code>.
</p>
<p>
  For hierarchy operators, <code>*</code> is shorthand for <code>concept</code>:
</p>
<pre><code data-vcl-expr-key="star-concept-hierarchy"></code></pre>
<div class="side-by-side">
  <div>
    <h4>Nested Membership</h4>
    <pre><code data-vcl-expr-key="walkthrough-ibuprofen-tablets"></code></pre>
  </div>
  <div>
    <h4>Dotted Path Rewrite</h4>
    <pre><code data-vcl-expr-key="walkthrough-ibuprofen-tablets-dotted"></code></pre>
  </div>
</div>
<p>
  Both forms mean: SCD concepts for ibuprofen oral tablets.
  <a class="try-link" href="tutorial.html#example=walkthrough-ibuprofen-tablets-dotted">Try dotted form</a>
</p>

<h4>A ValueSet URI</h4>
<pre><code data-vcl-expr-key="in-vs-uri-controlled-substances"></code></pre>
<p>
  Concepts whose <code>has_ingredient</code> value is a member of the referenced ValueSet.
</p>

<h3 id="expr-vs-include">ValueSet Includes</h3>
<p>
  The <code>^</code> prefix (without a property) includes all codes that are members of a referenced ValueSet:
</p>
<pre><code data-vcl-expr-key="compose-vs-include"></code></pre>
<p>
  This maps to <code>ValueSet.compose.include.valueSet</code>.
</p>
</section>

<!-- ================================================================ -->
<section id="operators">
<h2>Operators</h2>
<p>
  VCL filters map to
  <a href="https://build.fhir.org/valueset-definitions.html#ValueSet.compose.include.filter"><code>ValueSet.compose.include.filter</code></a>
  elements. Each filter has three parts:
</p>
<ul>
  <li><strong><code>property</code></strong> &mdash; the code system property to test
    (as declared in <a href="https://build.fhir.org/codesystem-definitions.html#CodeSystem.property"><code>CodeSystem.property</code></a>
    or <a href="https://build.fhir.org/codesystem-definitions.html#CodeSystem.filter"><code>CodeSystem.filter</code></a>)</li>
  <li><strong><code>op</code></strong> &mdash; the comparison operator, drawn from the
    <a href="https://build.fhir.org/codesystem-filter-operator.html"><code>filter-operator</code></a> CodeSystem</li>
  <li><strong><code>value</code></strong> &mdash; the value to compare against</li>
</ul>
<p>
  In VCL, the operator is expressed as a symbol between the property and value:
  <code>property {op-symbol} value</code>. Each VCL symbol maps to a specific
  <a href="https://build.fhir.org/valueset-filter-operator.html"><code>filter-operator</code></a> code.
  For example, VCL <code>has_ingredient=161</code> maps to
  <code>{"property": "has_ingredient", "op": "=", "value": "161"}</code>.
</p>
<table>
<tr>
    <th>FHIR&nbsp;Operator</th>
    <th>VCL</th>
    <th>Form</th>
    <th>Semantics</th>
  </tr>
  <tr>
    <td><code>=</code></td><td><code>=</code></td>
    <td><code>prop = value</code></td>
    <td>Property value equals the specified code/string.</td>
  </tr>
  <tr>
    <td><code>is-a</code></td><td><code>&lt;&lt;</code></td>
    <td><code>prop &lt;&lt; code</code></td>
    <td>Property value is the specified code or any of its descendants (subsumption).</td>
  </tr>
  <tr>
    <td><code>descendent-of</code></td><td><code>&lt;</code></td>
    <td><code>prop &lt; code</code></td>
    <td>Property value is a strict descendant of the specified code (not including the code itself).</td>
  </tr>
  <tr>
    <td><code>is-not-a</code></td><td><code>~&lt;&lt;</code></td>
    <td><code>prop ~&lt;&lt; code</code></td>
    <td>Property value is NOT the specified code and NOT any of its descendants.</td>
  </tr>
  <tr>
    <td><code>generalizes</code></td><td><code>&gt;&gt;</code></td>
    <td><code>prop &gt;&gt; code</code></td>
    <td>Property value is the specified code or any of its ancestors.</td>
  </tr>
  <tr>
    <td><code>child-of</code></td><td><code>&lt;!</code></td>
    <td><code>prop &lt;! code</code></td>
    <td>Property value is a direct child of the specified code.</td>
  </tr>
  <tr>
    <td><code>descendent-leaf</code></td><td><code>!!&lt;</code></td>
    <td><code>prop !!&lt; code</code></td>
    <td>Property value is a leaf descendant of the specified code (has no children).</td>
  </tr>
  <tr>
    <td><code>in</code></td><td><code>^</code></td>
    <td><code>prop ^ (values)</code></td>
    <td>Property value is a member of the specified set (code set expression, nested expression, or ValueSet).
      See <a href="#expr-in">"in" operator</a>.</td>
  </tr>
  <tr>
    <td><code>not-in</code></td><td><code>~^</code></td>
    <td><code>prop ~^ (values)</code></td>
    <td>Property value is NOT a member of the specified set.</td>
  </tr>
  <tr>
    <td><code>regex</code></td><td><code>/</code></td>
    <td><code>prop / "pattern"</code></td>
    <td>Property value matches the specified regular expression. The pattern <strong>MUST</strong>
      be a quoted string. In this prototype, <code>code</code> and <code>display</code> are built-in concept
      fields and may be used as <code>prop</code> (for example <code>code/"204"</code>). Extracted
      <code>designation</code> literals from term strings are also queryable (for example <code>designation/"[Ii]buprofen"</code>).</td>
  </tr>
  <tr>
    <td><code>exists</code></td><td><code>?</code></td>
    <td><code>prop ? bool:true</code></td>
    <td>Tests whether the property has any value. <code>?bool:true</code> matches concepts
      that have the property; <code>?bool:false</code> matches concepts that lack it.</td>
  </tr>
  <tr>
    <td><code>of</code></td><td><code>.</code></td>
    <td><code>value . prop</code></td>
    <td>Property navigation. Reverses the property/value roles: starts from the value side
      and follows the property. See <a href="#expr-of">"of" operator</a>.</td>
</tr>
</table>
<p><strong>Hierarchy note:</strong> <code>&lt;&lt;</code>, <code>&lt;</code>, <code>&gt;&gt;</code>, <code>&lt;!</code>, and <code>!!&lt;</code> operate over the named property. Use <code>concept</code> for code hierarchy (for example <code>concept&lt;&lt;369097</code>). In this RxNorm prototype, <code>concept</code> hierarchy is backed by <code>isa</code> edges.</p>
<p><strong>Regex note:</strong> <code>code/"..."</code> matches concept identifiers and <code>display/"..."</code> matches concept display text. <code>designation/"..."</code> matches extracted alternate labels from term strings. Other property names apply regex to that property's values.</p>
<p><strong>Property lhs rule:</strong> filter operators bind to a property path only: <code>code(.code)*</code>. Grouped expressions are set expressions and cannot appear on the left of filter operators (for example <code>(A;B)&lt;&lt;201</code> is invalid).</p>
<p><strong>Star hierarchy shorthand:</strong> <code>*&lt;&lt;X</code> is shorthand for <code>concept&lt;&lt;X</code> (similarly for <code>&lt;</code>, <code>&gt;&gt;</code>, <code>&lt;!</code>, <code>!!&lt;</code>, <code>~&lt;&lt;</code>).</p>

<div class="note">
  <strong>FHIR R6 features:</strong> The <code>of</code> operator is new in FHIR R6 and does not
  yet appear in the
  <a href="https://build.fhir.org/valueset-filter-operator.html"><code>filter-operator</code></a>
  ValueSet. Additionally, R6 extends <code>in</code>, <code>not-in</code>, and <code>of</code> to
  accept <strong>nested expressions</strong> as values (not just codes or ValueSet URIs). In earlier
  FHIR versions, the <code>filter.value</code> element is a plain string; nested expressions require
  R6's expanded compose model. See <a href="#compose-mapping">Compose Mapping</a> for details.
</div>
</section>

<!-- ================================================================ -->
<section id="system-scoping">
<h2>System Scoping</h2>
<p>
  By default, a VCL expression applies to a single code system (determined by context, e.g.,
  the <code>system</code> element in a <code>ValueSet.compose.include</code>). To explicitly
  scope an expression to a code system, prefix it with the system URI in parentheses:
</p>
<pre><code data-vcl-expr-key="scope-rxnorm-filter-ingredient-spaced"></code></pre>
<p>
  To build a multi-system ValueSet, use disjunction with different system prefixes:
</p>
<pre><code data-vcl-expr-key="scope-loinc-snomed-spaced"></code></pre>
<p>
  Each system-scoped sub-expression maps to a separate <code>include</code> element
  with its own <code>system</code> value.
</p>
</section>

<!-- ================================================================ -->
<section id="implicit-uris">
<h2>Implicit ValueSet URIs</h2>
<p>
  A VCL expression can be encoded as an <strong>implicit ValueSet URI</strong> &mdash; a URL
  that serves as both identifier and definition for a ValueSet. This enables ad-hoc use
  with <code>$expand</code> without creating a stored ValueSet resource.
</p>

<h3>URL Structure</h3>
<dl>
  <dt>Base URL</dt>
  <dd><code>http://fhir.org/VCL</code></dd>
  <dt>Query parameter</dt>
  <dd><code>?v1=[percent-encoded expression]</code></dd>
</dl>
<p>
  The <code>[expression]</code> portion <strong>MUST</strong> be percent-encoded per RFC 3986.
  Terminology servers processing a VCL implicit ValueSet URL <strong>SHALL</strong> percent-decode
  the expression before interpreting it.
</p>
<p>
  VCL expressions used in implicit URIs <strong>MUST</strong> include
  <a href="#system-scoping">system scoping</a> to identify the target code system(s).
</p>

<h3>Example</h3>
<p>Given the VCL expression:</p>
<pre><code data-vcl-expr-key="scope-rxnorm-and-ingredient-df"></code></pre>
<p>The implicit ValueSet URI is formed by percent-encoding the expression into the <code>v1</code> query parameter:</p>
<pre><code>http://fhir.org/VCL?v1=(http%3A%2F%2Fwww.nlm.nih.gov%2Fresearch%2Fumls%2Frxnorm)(has_ingredient%3D161%2Chas_dose_form%3D317541)</code></pre>
<p>
  Characters that are syntactically significant in a URL query string &mdash; such as <code>:</code>,
  <code>/</code>, <code>=</code>, and <code>,</code> &mdash; are percent-encoded so the expression
  travels safely as a single parameter value.
</p>

<h3>Usage with <code>$expand</code></h3>
<p>
  To expand a VCL implicit ValueSet via
  <a href="https://build.fhir.org/valueset-operation-expand.html"><code>$expand</code></a>,
  pass the implicit URI as the <code>url</code> parameter. Because the implicit URI itself
  contains query-string syntax (<code>?v1=...</code>), it must be percent-encoded again
  when used as a parameter value, producing <strong>double encoding</strong>.
</p>
<p>Using a POST-based <code>$expand</code> with a <code>Parameters</code> resource body avoids
  double encoding &mdash; the implicit URI is sent as-is in the <code>url</code> parameter value.</p>
<p>Example with a GET request:</p>
<pre><code>GET [base]/ValueSet/$expand
  ?url=http%3A%2F%2Ffhir.org%2FVCL%3Fv1%3D
    (http%253A%252F%252Fwww.nlm.nih.gov%252Fresearch%252Fumls%252Frxnorm)
    (has_ingredient%253D161%252Chas_dose_form%253D317541)</code></pre>
<p>The server decodes <code>?url=</code> once to recover the implicit URI, then decodes
  <code>?v1=</code> to recover the raw VCL expression.</p>
</section>

<!-- ================================================================ -->
<section id="compose-mapping">
<h2>Mapping to ValueSet.compose</h2>
<p>
  Every VCL expression has a direct structural correspondence to <code>ValueSet.compose</code>.
  This section defines the mapping.
</p>
<p>
  The examples below include the system URI prefix on each expression, since the compose
  output depends on it. Recall that VCL expressions include a system prefix via
  <code>(systemUri)(...)</code> &mdash; this maps directly to the <code>system</code> element
  in each <code>include</code>/<code>exclude</code>.
</p>

<h3>Code literal</h3>
<p><code data-vcl-expr-key="compose-code-literal-rxnorm"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-code-literal-rxnorm"></code></pre>

<h3>Single filter</h3>
<p><code data-vcl-expr-key="scope-rxnorm-filter-ingredient-spaced"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-filter-rxnorm"></code></pre>

<h3>Conjunction (AND)</h3>
<p>Multiple filters within a conjunction map to multiple <code>filter</code> entries
  in a <strong>single</strong> <code>include</code>.</p>
<p><code data-vcl-expr-key="scope-rxnorm-and-ingredient-df"></code> &rarr;</p>
<pre><code data-vcl-compose-key="scope-rxnorm-and-ingredient-df"></code></pre>

<h3>Disjunction (OR)</h3>
<p>Each operand in a disjunction maps to a <strong>separate</strong> <code>include</code>.</p>
<p><code data-vcl-expr-key="compose-disjunction-rxnorm"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-disjunction-rxnorm"></code></pre>

<h3>Exclusion</h3>
<p>The left side maps to <code>include</code>, the right side to <code>exclude</code>.</p>
<p><code data-vcl-expr-key="compose-exclusion-rxnorm"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-exclusion-rxnorm"></code></pre>

<h3>System scoping</h3>
<p>The system URI prefix maps to the <code>system</code> element in each <code>include</code>/<code>exclude</code>.</p>
<p><code data-vcl-expr-key="compose-system-scoping"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-system-scoping"></code></pre>

<h3>ValueSet include</h3>
<p><code data-vcl-expr-key="compose-vs-include"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-vs-include"></code></pre>

<h3>The "of" operator (single hop)</h3>
<p><code data-vcl-expr-key="compose-of-single-hop-rxnorm"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-of-single-hop-rxnorm"></code></pre>

<h3>The "of" operator (chained multi-hop)</h3>
<p>When an <code>of</code> operator has a complex inner expression, the compose output references
a separate ValueSet via a <strong>VCL URL</strong>. The inner expression becomes its own ValueSet,
identified by <code>http://fhir.org/VCL?v1=(system)(expression)</code>.</p>
<p><code data-vcl-expr-key="compose-of-chained-rxnorm"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-of-chained-rxnorm"></code></pre>

<h3>Nested expression membership</h3>
<p>Similarly, <code>in</code> or <code>not-in</code> with a nested expression emits a VCL URL reference
to a separate ValueSet containing the nested expression.</p>
<p><code data-vcl-expr-key="compose-nested-expression-membership-rxnorm"></code> &rarr;</p>
<pre><code data-vcl-compose-key="compose-nested-expression-membership-rxnorm"></code></pre>
<div class="note">
  <strong>FHIR version notes:</strong> The <code>of</code> filter operator is introduced in
  FHIR R6. In earlier FHIR versions, <code>of</code> must be represented as an extension on
  the <code>filter</code> element. Similarly, R6 extends <code>in</code> and <code>not-in</code>
  to accept nested expressions as values; pre-R6 implementations require extensions for this.
  <br><br>
  Complex nested expressions (chained <code>of</code>, <code>in</code>/<code>not-in</code> with
  nested expressions) are represented as references to separate ValueSets identified by VCL URLs
  (<code>http://fhir.org/VCL?v1=(system)(expression)</code>). This keeps each
  <code>ValueSet.compose</code> flat &mdash; filter values are always strings, never nested objects.
</div>
</section>

<!-- ================================================================ -->
<section id="grammar">
<h2>Formal Grammar</h2>
<p>
  The authoritative VCL grammar, defined in <a href="https://www.antlr.org/">ANTLR 4</a>,
  with parser rules followed by lexer token definitions:
</p>
<div class="note">
  Validation: [x] Last validated 2026-02-09 via
  <a href="https://github.com/jmandel/vcl-playground/blob/main/scripts/check-antlr-generated.sh"><code>scripts/check-antlr-generated.sh</code></a>.
</div>
<pre class="grammar"><code data-antlr-grammar></code></pre>
</section>

</div><!-- /.container -->
<script type="module" src="./spec-app.ts"></script>
<script type="module" src="./branch-picker.ts"></script>
<script>
document.querySelectorAll('h2, h3').forEach(h => {
  const id = h.id || (h.closest('section') && h.closest('section').id);
  if (!id) return;
  const a = document.createElement('a');
  a.className = 'anchor-link';
  a.href = '#' + id;
  a.textContent = '#';
  a.title = 'Copy link';
  a.addEventListener('click', e => {
    e.preventDefault();
    const url = location.href.replace(/#.*$/, '') + '#' + id;
    navigator.clipboard.writeText(url).then(() => {
      a.textContent = 'Copied!';
      a.classList.add('copied');
      setTimeout(() => { a.textContent = '#'; a.classList.remove('copied'); }, 1200);
    });
  });
  h.appendChild(a);
});
</script>
</body>
</html>
